<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MultiFader Configurator</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="language-container" class="language-container">
    <span id="language-label" class="language-button">üåê Change language</span>
    <div id="language-options" class="language-options">
      <div data-lang="it">üáÆüáπ Italiano</div>
      <div data-lang="en">üá¨üáß English</div>
    </div>
  </div>

  <div class="panel">
    <h1 class="panel-title" id="panelTitle"><span class="fader-name">MultiFader</span> Configurator</h1>
    <div class="top-bar">
      
      <div class="switch-container">
        <label class="switch-label">
          <input type="checkbox" id="toggleSwitch" disabled />
          <span class="slider-switch"></span>
        </label>
      </div>

      <div class="fader-toggle-wrapper">
        <label class="fader-toggle-label">
          <input type="checkbox" id="faderToggle" />
          <span class="fader-switch"></span>
          <span class="fader-text" id="faderText">Disable Fader 1-3</span>
        </label>
        <div class="led-controls">
          <button class="led-button" id="ledButton"></button>
          <input type="range" min="0" max="254" value="127" class="led-slider" id="ledSlider">
        </div>
      </div>

      <button id="connectButton">Connect</button>
    </div>

    <div class="container container-1"></div>
    <div class="container container-2" style="display: none;"></div>

    <div class="keyboard-layout-section" id="keyboardLayoutSection">
      <div class="keyboard-layout-label">Keyboard Layout for Hotkeys</div>
      <select class="keyboard-layout-select" id="keyboardLayoutSelect" onchange="currentKeyboardLayoutCode = parseInt(this.value)">
        <option value="0">English (US)</option>
        <option value="1">Italiano</option>
        <option value="2">Magyar</option>
        <option value="3">Espa√±ol</option>
        <option value="4">Fran√ßais</option>
        <option value="5">Portugu√™s</option>
        <option value="6">Svenska</option>
        <option value="7">Dansk</option>
        <option value="8">Deutsch</option>      
      </select>
    </div>

    <div class="hotkey-spoiler">
      <div class="hotkey-spoiler-header">
        <span>‚ÑπÔ∏è Automatic Hotkey Information</span>
        <span class="spoiler-arrow">‚ñº</span>
      </div>
      <div class="hotkey-spoiler-content">
        <p>
          You can change the active shortcuts by capturing different key sequences that will then be activated when the corresponding Fader goes towards 0 ‚¨áÔ∏è, or when it moves away from 0 ‚¨ÜÔ∏è.
          <br /><br />
          üéß What can this system be used for? An example with deej could be associating shortcuts to Play/Pause a multimedia application so that when lowering the volume, playback doesn't continue. When the volume is raised again, the second shortcut can be useful to automatically restart the multimedia content.
          <br /><br />
          üéº In MIDI performance, for example: when the fader reaches 0, a shortcut can disable effects; when raised again, another shortcut restores them automatically.
        </p>
      </div>
    </div>
    
    <button id="saveButton">Store on Device</button>
    <h4 id="saveButtonDescription">Store the current configuration on the device so it persists after a reboot</h4>
  </div>

  <script>

    document.addEventListener("DOMContentLoaded", function() {
      const userLang = localStorage.getItem("lang") || navigator.language || navigator.userLanguage;
      const langCode = userLang.substring(0, 2);
      if (langCode === "it") {
        window.location.href = "index.html";
      }
      
      const languageLabel = document.getElementById("language-label");
      const languageOptions = document.getElementById("language-options");

      languageLabel.addEventListener("click", function(e) {
        e.stopPropagation();
        languageOptions.style.display = (languageOptions.style.display === "block") ? "none" : "block";
      });

      const options = languageOptions.querySelectorAll("div[data-lang]");
      options.forEach(function(option) {
        option.addEventListener("click", function() {
          const selectedLang = this.getAttribute("data-lang");
          localStorage.setItem("lang", selectedLang);
          window.location.href = (selectedLang === "en") ? "index-en.html" : "index.html";
        });
      });

      document.addEventListener("click", function(e) {
        if (!document.getElementById("language-container").contains(e.target)) {
          languageOptions.style.display = "none";
        }
      });
    });
    
    const group1 = document.querySelector('.container-1');
    const group2 = document.querySelector('.container-2');
    const faderToggle = document.getElementById('faderToggle');
    const faderText = document.getElementById('faderText');
    const toggle = document.getElementById('toggleSwitch');
    const connectBtn = document.getElementById('connectButton');
    const saveBtn = document.getElementById('saveButton');
    const saveDesc = document.getElementById('saveButtonDescription');
    const panelTitle = document.getElementById('panelTitle');
    const keyboardLayoutSection = document.getElementById('keyboardLayoutSection');
    const keyboardLayoutSelect = document.getElementById('keyboardLayoutSelect');
    const ledButton = document.getElementById('ledButton');
    const ledSlider = document.getElementById('ledSlider');
	
    let NUM_FADER = 6;
    let faderStateA = false;
    let faderStateB = false;
    let ledStateA = false;
    let ledStateB = false;
    let ledValueA = 127;
    let ledValueB = 127;
    let currentSession = 'A';
    let buffer = '';
    let currentKeyboardLayout = 'en-US';
    let currentKeyboardLayoutCode = 0;

    let midiOn = [];
    let hotkeyOn = [];
    let midiChannels = [];
    let midiControlChanges = [];

    let captureStates = {};

    const supportedLayouts = {
  'en-US': 0,
  'it-IT': 1,
  'hu-HU': 2,
  'es-ES': 3,
  'fr-FR': 4,
  'pt-PT': 5,
  'sv-SE': 6,
  'da-DK': 7,
  'de-DE': 8
};

function detectAndSetDefaultKeyboardLayout() {
  const browserLang = navigator.language || navigator.userLanguage;

  if (browserLang in supportedLayouts) {
    currentKeyboardLayoutCode = supportedLayouts[browserLang];
  } else {
    const langCode = browserLang.split('-')[0];
    const matchingKey = Object.keys(supportedLayouts).find(
      layout => layout.startsWith(langCode + '-')
    );
    if (matchingKey) {
      currentKeyboardLayoutCode = supportedLayouts[matchingKey];
    }
  }

  keyboardLayoutSelect.value = currentKeyboardLayoutCode.toString();
}

function sendKeyboardLayoutToDevice() {
  sendCommand(`k,${currentKeyboardLayoutCode}`);
  console.log(`üì§ Sent keyboard layout: ${currentKeyboardLayoutCode}`);
}

    keyboardLayoutSelect.addEventListener('change', () => {
      currentKeyboardLayout = keyboardLayoutSelect.value;
      sendKeyboardLayoutToDevice();
    });

    function handleVolumeMessage(volumeIndexValue) {
      for (let i = 0; i < NUM_FADER; i++) {
        midiOn[i] = (volumeIndexValue & (1 << i)) !== 0;
      }
      
      document.querySelectorAll('.slider-container').forEach((container, index) => {
        const modeSelect = container.querySelector('.mode-select');
        const slider = container.querySelector('.slider');
        if (midiOn[index]) {
          modeSelect.value = 'midi';
          slider.classList.add('midi-mode');
        } else {
          modeSelect.value = 'volume';
          slider.classList.remove('midi-mode');
        }
        updateUI(container);
      });
      
      const isVolumeMode = !document.getElementById('faderToggle').checked;
      const isSessionActive = checkSessionStatus();
      updateAllFaders(isVolumeMode, isSessionActive);
    }

    function handleSliderValues(valuesString) {
      const isCurrentSessionDisabled = (currentSession === 'A' && faderStateA) || 
                                      (currentSession === 'B' && faderStateB);
      
      if (isCurrentSessionDisabled) {
        return;
      }
      
      const values = valuesString.split('|');
      
      if (values.length === NUM_FADER) {
        values.forEach((value, index) => {
          const rawValue = parseInt(value);
          if (!isNaN(rawValue) && rawValue >= 0 && rawValue <= 1023) {
            updateFaderDisplays(index + 1, rawValue);
          }
        });
      } else if (values.length === NUM_FADER / 2) {
        const halfFaders = NUM_FADER / 2;
        values.forEach((value, index) => {
          const rawValue = parseInt(value);
          if (!isNaN(rawValue) && rawValue >= 0 && rawValue <= 1023) {
            let faderIndex;
            if (currentSession === 'A') {
              faderIndex = index + 1;
            } else {
              faderIndex = index + halfFaders + 1;
            }
            
            updateFaderDisplays(faderIndex, rawValue);
          }
        });
      }
    }

    function updateFaderDisplays(faderIndex, rawValue) {
      const isCurrentSessionDisabled = (currentSession === 'A' && faderStateA) || 
                                      (currentSession === 'B' && faderStateB);
      
      if (isCurrentSessionDisabled) {
        return;
      }
      
      const sliderValue = Math.round((rawValue / 1023) * 100);
      
      const sliderId = `slider${faderIndex}`;
      const positionId = `position${faderIndex}`;
      
      const slider = document.getElementById(sliderId);
      const positionDisplay = document.getElementById(positionId);
      
      if (slider) {
        slider.value = sliderValue;
      }
      
      const faderArrayIndex = faderIndex - 1;
    }

    function handleHotkeyMessage(hotkeyIndexValue) {
      for (let i = 0; i < NUM_FADER; i++) {
        hotkeyOn[i] = (hotkeyIndexValue & (1 << i)) !== 0;
      }
      
      let anyHotkeyEnabled = hotkeyOn.some(enabled => enabled);
      keyboardLayoutSection.style.display = anyHotkeyEnabled ? 'block' : 'none';
      
      document.querySelectorAll('.slider-container').forEach((container, index) => {
        const hotkeyToggle = container.querySelector('.hotkey-toggle input[type="checkbox"]');
        const hotkeySection = container.querySelector('.hotkey-capture-section');

        if (hotkeyToggle) {
          hotkeyToggle.checked = hotkeyOn[index];
          
          if (hotkeySection) {
            hotkeySection.style.display = hotkeyOn[index] ? 'flex' : 'none';
          }
        }
      });
      
      if (anyHotkeyEnabled) {
        sendKeyboardLayoutToDevice();
      }
    }

    function getOperatingSystem() {
    const platform = navigator.platform.toLowerCase();
    const userAgent = navigator.userAgent.toLowerCase();
    
    if (platform.includes('mac') || userAgent.includes('mac os')) {
      return 'mac';
    } else if (platform.includes('linux') || userAgent.includes('linux')) {
      return 'linux';
    } else if (platform.includes('win') || userAgent.includes('windows')) {
      return 'windows';
    }
    
    return 'windows';
  }

function convertKeysToHex(keys) {
  if (keys.length === 0) return null;
  
  let modifiers = 0;
  let mainKeyHex = 0;
  
  keys.forEach(key => {
    const lowerKey = key.toLowerCase();
    
    switch(lowerKey) {
      case 'ctrl':
        modifiers |= 0x01;
        break;
      case 'alt':
        modifiers |= 0x02;
        break;
      case 'shift':
        modifiers |= 0x04;
        break;
      case 'win':
      case 'cmd':
      case 'super':
        modifiers |= 0x08;
        break;
      default:
        const keyHex = getKeyHex(key);
        if (keyHex !== null) {
          mainKeyHex = keyHex;
        }
        break;
    }
  });
  
  return `${modifiers.toString(16).padStart(2, '0').toUpperCase()},${mainKeyHex.toString(16).padStart(2, '0').toUpperCase()}`;
}

function handleKeyCapture(event, faderIndex, direction) {
  event.preventDefault();
  event.stopPropagation();
  
  const pressedKeys = [];
  
  if (event.ctrlKey) pressedKeys.push('Ctrl');
  if (event.altKey) pressedKeys.push('Alt');
  if (event.shiftKey) pressedKeys.push('Shift');
  if (event.metaKey) pressedKeys.push(getModifierKeyName('Win'));
  
  if (event.key === 'AltGraph' && !event.ctrlKey && !event.altKey) {
    pressedKeys.push('Ctrl');
    pressedKeys.push('Alt');
  }
  
  const key = event.key;
  
  if (['Control', 'Alt', 'Shift', 'Meta', 'OS', 'AltGraph'].includes(key)) {
    return;
  }
  
  const keyHex = getKeyHex(key);
  if (keyHex !== null) {
    pressedKeys.push(key);
  } else {
    console.warn(`Unmapped key: ${key}`);
    return;
  }
  
  if (pressedKeys.length > 0) {
    captureStates[faderIndex][direction].keys = pressedKeys;
    updateHotkeyDisplay(faderIndex, direction);
    
    const hexCommand = convertKeysToHex(pressedKeys);
    console.log(`Hotkey captured for Fader ${faderIndex} ${direction}: ${pressedKeys.join(' + ')} -> ${hexCommand}`);
    
    setTimeout(() => {
      if (captureStates[faderIndex] && captureStates[faderIndex][direction].capturing) {
        toggleHotkeyCapture(faderIndex, direction);
      }
    }, 300);
  }
}

function getModifierKeyName(key) {
  const os = getOperatingSystem();
  
  const keyMappings = {
    'win': {
      'mac': 'Cmd',
      'linux': 'Super',
      'windows': 'Win'
    },
    'Win': {
      'mac': 'Cmd',
      'linux': 'Super',
      'windows': 'Win'
    },
    'meta': {
      'mac': 'Cmd',
      'linux': 'Super', 
      'windows': 'Win'
    },
    'Meta': {
      'mac': 'Cmd',
      'linux': 'Super',
      'windows': 'Win'
    }
  };
  
  const lowerKey = key.toLowerCase();
  if (keyMappings[lowerKey]) {
    return keyMappings[lowerKey][os];
  }
  
  return key;
}

    function toggleHotkeyCapture(faderIndex, direction) {
      if (!captureStates[faderIndex]) {
        captureStates[faderIndex] = {
          down: {capturing: false, keys: []},
          up: {capturing: false, keys: []}
        };
      }
      
      const captureState = captureStates[faderIndex][direction];
      const btn = document.querySelector(`#hotkey-capture-${direction}-${faderIndex}`);
      
      if (!captureState.capturing) {
        captureState.capturing = true;
        captureState.keys = [];
        btn.textContent = 'üõë Stop';
        btn.classList.add('capturing');
        updateHotkeyDisplay(faderIndex, direction);
      } else {
        captureState.capturing = false;
        btn.textContent = `Capture ${direction === 'down' ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è'}`;
        btn.classList.remove('capturing');
      }
    }

    function updateHotkeyDisplay(faderIndex, direction) {
      const display = document.querySelector(`#hotkey-display-${direction}-${faderIndex}`);
      if (!display) return;

      const captureState = captureStates[faderIndex] && captureStates[faderIndex][direction];
      if (!captureState || captureState.keys.length === 0) {
        display.className = 'hotkey-capture-display';
        display.innerHTML = '';
        return;
      }

      display.className = 'hotkey-capture-display captured';
      const keyStrings = captureState.keys.map(key => `<span class="key-combo">${key}</span>`);
      display.innerHTML = keyStrings.join(' + ');
    }

const keyToHexMap = {
  'Backspace': 0xB2,
  'CapsLock': 0xC1,
  'Delete': 0xD4,
  'ArrowDown': 0xD9,
  'End': 0xD5,
  'Enter': 0xB0,
  'Escape': 0xB1,
  'Esc': 0xB1,
  'F1': 0xC2,
  'F2': 0xC3,
  'F3': 0xC4,
  'F4': 0xC5,
  'F5': 0xC6,
  'F6': 0xC7,
  'F7': 0xC8,
  'F8': 0xC9,
  'F9': 0xCA,
  'F10': 0xCB,
  'F11': 0xCC,
  'F12': 0xCD,
  'F13': 0xF0,
  'F14': 0xF1,
  'F15': 0xF2,
  'F16': 0xF3,
  'F17': 0xF4,
  'F18': 0xF5,
  'F19': 0xF6,
  'F20': 0xF7,
  'F21': 0xF8,
  'F22': 0xF9,
  'F23': 0xFA,
  'F24': 0xFB,
  'Home': 0xD2,
  'Insert': 0xD1,
  'ArrowLeft': 0xD8,
  'Left': 0xD8,
  'AltLeft': 0x82,
  'ControlLeft': 0x80,
  'MetaLeft': 0x83,
  'ShiftLeft': 0x81,
  'ContextMenu': 0xED,
  'Menu': 0xED,
  'ArrowRight': 0xD7,
  'Right': 0xD7,
  'AltRight': 0x86,
  'ControlRight': 0x84,
  'MetaRight': 0x87,
  'ShiftRight': 0x85,
  'ScrollLock': 0xCF,
  ' ': 0x20,
  'Tab': 0xB3,
  'ArrowUp': 0xDA,
  'Up': 0xDA,
  'Down': 0xD9,
  'NumLock': 0xDB,
  'PageUp': 0xD3,
  'PageDown': 0xD6,
  'Pause': 0xD0,
  'PrintScreen': 0xCE,
  'Win': 0x83,
  'Ctrl': 0x80,
  'Alt': 0x82,
  'Shift': 0x81,
  'Cmd': 0x83,
  'Super': 0x83,
  'Numpad0': 0xEA,
  'Numpad1': 0xE1,
  'Numpad2': 0xE2,
  'Numpad3': 0xE3,
  'Numpad4': 0xE4,
  'Numpad5': 0xE5,
  'Numpad6': 0xE6,
  'Numpad7': 0xE7,
  'Numpad8': 0xE8,
  'Numpad9': 0xE9,
  'NumpadDivide': 0xDC,
  'NumpadDecimal': 0xEB,
  'NumpadEnter': 0xE0,
  'NumpadSubtract': 0xDE,
  'NumpadMultiply': 0xDD,
  'NumpadAdd': 0xDF,
  'AltGraph': 0xc0
};

    const keyboardSpecialChars = {
'it-IT': {
  '√†': 136 + 0x34,
  '√®': 136 + 0x2f,
  '√¨': 136 + 0x2e,
  '√≤': 136 + 0x33,
  '√π': 136 + 0x31,
},
'hu-HU': {
  '√°': 136 + 0x34,
  '√©': 136 + 0x33,
  '√≠': 136 + 0x32,
  '√≥': 136 + 0x2e,
  '√∫': 136 + 0x30,
  '√∂': 136 + 0x27,
  '√º': 136 + 0x2d,
  '≈ë': 136 + 0x2f,
  '≈±': 136 + 0x31,
},
'es-ES': {
  '√°': 136 + 0x34,
  '√©': 136 + 0x2f,
  '√≠': 136 + 0x2e,
  '√≥': 136 + 0x33,
  '√∫': 136 + 0x31,
  '√±': 136 + 0x33,
  '√º': 136 + 0x30,
},
'fr-FR': {
  '√†': 136 + 0x27,
  '√®': 136 + 0x24,
  '√©': 136 + 0x1f,
  '√π': 136 + 0x34,
  '√ß': 136 + 0x26,
  '√¢': 136 + 0x2f,
  '√™': 136 + 0x2f,
  '√Æ': 136 + 0x2f,
  '√¥': 136 + 0x2f,
  '√ª': 136 + 0x2f,
},
'pt-PT': {
  '√°': 136 + 0x30,
  '√†': 136 + 0x38,
  '√¢': 136 + 0x39,
  '√£': 136 + 0x3a,
  '√©': 136 + 0x2f,
  '√™': 136 + 0x3b,
  '√≠': 136 + 0x2e,
  '√≥': 136 + 0x33,
  '√¥': 136 + 0x3c,
  '√µ': 136 + 0x3d,
  '√∫': 136 + 0x31,
  '√ß': 136 + 0x33,
},
'sv-SE': {
  '√•': 136 + 0x2f,
  '√§': 136 + 0x34,
  '√∂': 136 + 0x33,
},
'da-DK': {
  '√¶': 136 + 0x33,
  '√∏': 136 + 0x34,
  '√•': 136 + 0x2f,
},
'de-DE': {
  '√§': 136 + 0x34,
  '√∂': 136 + 0x33,
  '√º': 136 + 0x2f,
  '√ü': 136 + 0x2d,
}

};


function getKeyHex(key) {
  const extendedKeyMap = {
    ...keyToHexMap,
    'AltGraph': 0x86
  };
  
  if (extendedKeyMap[key]) {
    return extendedKeyMap[key];
  }
  
  const currentLayoutCode = parseInt(keyboardLayoutSelect.value);
  const layoutName = Object.keys(supportedLayouts).find(
    layout => supportedLayouts[layout] === currentLayoutCode
  );
  
  if (layoutName && keyboardSpecialChars[layoutName] && keyboardSpecialChars[layoutName][key]) {
    return keyboardSpecialChars[layoutName][key];
  }
  
  if (key.length === 1) {
    const charCode = key.charCodeAt(0);
    if (charCode <= 127) {
      return charCode;
    }
  }
  
  console.warn(`Unmapped key for layout ${layoutName}: "${key}" (charCode: ${key.charCodeAt(0)})`);
  return null;
}

    function sendHotkeys(faderIndex) {
      const downKeys = captureStates[faderIndex] && captureStates[faderIndex].down.keys || [];
      const upKeys = captureStates[faderIndex] && captureStates[faderIndex].up.keys || [];
      
      if (downKeys.length === 0 && upKeys.length === 0) {
        console.log('No hotkeys to send');
        return;
      }
      
      if (downKeys.length > 0) {
        const hexCommand = convertKeysToHex(downKeys);
        if (hexCommand) {
          sendCommand(`hd,${faderIndex - 1},${hexCommand}`);
          console.log(`üì§ Sent hotkey down for Fader ${faderIndex}: ${hexCommand}`);
        }
      }
      
      if (upKeys.length > 0) {
        const hexCommand = convertKeysToHex(upKeys);
        if (hexCommand) {
          sendCommand(`hu,${faderIndex - 1},${hexCommand}`);
          console.log(`üì§ Sent hotkey up for Fader ${faderIndex}: ${hexCommand}`);
        }
      }
    }

    function sendVolumeBitmask() {
      const bitmask = midiOn.reduce((acc, val, i) => acc | (val ? (1 << i) : 0), 0);
      sendCommand(`v,${bitmask}`);
      console.log(`üì§ Sent volume bitmask: ${bitmask} (binary: ${bitmask.toString(2).padStart(NUM_FADER, '0')})`);
    }

    function updateFaderToggleUI() {
      const halfFaders = NUM_FADER / 2;
      if (currentSession === 'A') {
        faderToggle.checked = faderStateA;
        faderText.textContent = `Disable Fader 1-${halfFaders}`;
        ledButton.classList.toggle('active', ledStateA);
        ledSlider.value = ledValueA;
      } else {
        faderToggle.checked = faderStateB;
        faderText.textContent = `Disable Fader ${halfFaders + 1}-${NUM_FADER}`;
        ledButton.classList.toggle('active', ledStateB);
        ledSlider.value = ledValueB;
      }
      
      const isVolumeMode = !faderToggle.checked;
      const isSessionActive = checkSessionStatus();
      updateAllFaders(isVolumeMode, isSessionActive);
      
      if (!faderToggle.checked && port && writer) {
        setTimeout(() => {
          sendCommand("stato_slider");
        }, 100);
      }
    }

    faderToggle.addEventListener('change', () => {
      if (currentSession === 'A') {
        faderStateA = faderToggle.checked;
        if (faderStateA) {
          sendCommand("off_a");
        } else {
          sendCommand("on_a");
        }
      } else {
        faderStateB = faderToggle.checked;
        if (faderStateB) {
          sendCommand("off_b");
        } else {
          sendCommand("on_b");
        }
      }
      
      const isVolumeMode = !faderToggle.checked;
      const isSessionActive = checkSessionStatus();
      updateAllFaders(isVolumeMode, isSessionActive);
    });

    ledButton.addEventListener('click', () => {
      if (currentSession === 'A') {
        ledStateA = !ledStateA;
        sendCommand(`la,${ledStateA ? 1 : 0},${ledSlider.value}`);
      } else {
        ledStateB = !ledStateB;
        sendCommand(`lb,${ledStateB ? 1 : 0},${ledSlider.value}`);
      }
      updateFaderToggleUI();
    });

    ledSlider.addEventListener('input', () => {
      if (currentSession === 'A') {
        ledValueA = parseInt(ledSlider.value);
        if (ledStateA) {
          sendCommand(`la,1,${ledValueA}`);
        }
      } else {
        ledValueB = parseInt(ledSlider.value);
        if (ledStateB) {
          sendCommand(`lb,1,${ledValueB}`);
        }
      }
    });

    saveBtn.addEventListener('click', () => {
      sendCommand("salva");
      alert("Configuration saved to device. Press the Disconnect button to allow detection by other programs.");
      console.log('üì§ Sent command: salva');
    });

    function createSliders() {
      group1.innerHTML = '';
      group2.innerHTML = '';
      
      const halfFaders = NUM_FADER / 2;
      
      for (let i = 1; i <= halfFaders; i++) {
        group1.appendChild(createSlider(i, `Fader ${i}`));
      }
      
      for (let i = halfFaders + 1; i <= NUM_FADER; i++) {
        group2.appendChild(createSlider(i, `Fader ${i}`));
      }
      
      midiOn = new Array(NUM_FADER).fill(false);
      hotkeyOn = new Array(NUM_FADER).fill(false);
      midiChannels = new Array(NUM_FADER).fill(0);
      midiControlChanges = new Array(NUM_FADER).fill(0);
      
      captureStates = {};
      for (let i = 1; i <= NUM_FADER; i++) {
        captureStates[i] = {
          down: {capturing: false, keys: []},
          up: {capturing: false, keys: []}
        };
      }
      
      populateSelects();
      addEventListeners();
      
      console.log(`üì© Created ${NUM_FADER} faders (${halfFaders} per group)`);
    }

    const createSlider = (id, label) => {
      const container = document.createElement('div');
      container.className = 'slider-container';
      container.dataset.index = id;

      container.innerHTML = `
      <div class="label">${label}</div>
      <div class="slider-wrapper">
        <input type="range" min="0" max="100" value="50" class="slider" id="slider${id}">
      </div>
      <select class="mode-select">
        <option value="volume">Volume ${id-1}</option>
        <option value="midi">MIDI</option>
      </select>
      <div class="midi-options">
        <select class="channel-select">
          <option selected disabled>Channel</option>
        </select>
        <select class="cc-select">
          <option selected disabled>Control Change</option>
        </select>
      </div>
      <div class="hotkey-toggle">
        <label><input type="checkbox"> Hotkey</label>
      </div>
      <div class="hotkey-capture-section">
        <div class="hotkey-capture-row">
          <div class="hotkey-label"></div>
          <div class="hotkey-capture-display" id="hotkey-display-down-${id}">Hotkey ‚¨áÔ∏è</div>
          <button class="hotkey-capture-btn" id="hotkey-capture-down-${id}">Capture ‚¨áÔ∏è</button>
        </div>
        <div class="hotkey-capture-row">
          <div class="hotkey-label"></div>
          <div class="hotkey-capture-display" id="hotkey-display-up-${id}">Hotkey ‚¨ÜÔ∏è</div>
          <button class="hotkey-capture-btn" id="hotkey-capture-up-${id}">Capture ‚¨ÜÔ∏è</button>
        </div>
        <button class="hotkey-send-btn" onclick="sendHotkeys(${id})">Send</button>
      </div>
    `;
      return container;
    };

    function updateUI(container) {
      const select = container.querySelector('.mode-select');
      const midi = container.querySelector('.midi-options');
      if (select.value === 'midi') {
        midi.style.display = 'flex';
      } else {
        midi.style.display = 'none';
      }
    }

    function addEventListeners() {
      document.querySelectorAll('.slider-container').forEach((container, index) => {
        const modeSelect = container.querySelector('.mode-select');
        const channelSelect = container.querySelector('.channel-select');
        const ccSelect = container.querySelector('.cc-select');
        const hotkeyToggle = container.querySelector('.hotkey-toggle input[type="checkbox"]');
        const hotkeySection = container.querySelector('.hotkey-capture-section');
        const slider = container.querySelector('.slider');

        modeSelect.addEventListener('change', () => {
          if (modeSelect.value === 'midi') {
            midiOn[index] = true;
            slider.classList.add('midi-mode');
            const channelValue = parseInt(channelSelect.value) || 0;
            const ccValue = parseInt(ccSelect.value) || 0;
            sendCommand(`m,${index},${channelValue},${ccValue}`);
          } else {
            midiOn[index] = false;
            slider.classList.remove('midi-mode');
          }
          
          sendVolumeBitmask();
          updateUI(container);
          
          const isVolumeMode = !document.getElementById('faderToggle').checked;
          const isSessionActive = checkSessionStatus();
          updateAllFaders(isVolumeMode, isSessionActive);
        });

        channelSelect.addEventListener('change', () => {
          if (modeSelect.value === 'midi') {
            const channelValue = parseInt(channelSelect.value);
            midiChannels[index] = channelValue;
            const ccValue = parseInt(ccSelect.value) || 0;
            sendCommand(`m,${index},${channelValue},${ccValue}`);
          }
        });

        ccSelect.addEventListener('change', () => {
          if (modeSelect.value === 'midi') {
            const ccValue = parseInt(ccSelect.value);
            midiControlChanges[index] = ccValue;
            const channelValue = parseInt(channelSelect.value) || 0;
            sendCommand(`m,${index},${channelValue},${ccValue}`);
          }
        });

        hotkeyToggle.addEventListener('change', () => {
          hotkeyOn[index] = hotkeyToggle.checked;
          const bitmask = hotkeyOn.reduce((acc, val, i) => acc | (val ? (1 << i) : 0), 0);
          sendCommand(`h,${bitmask}`);
          
          if (hotkeySection) {
            hotkeySection.style.display = hotkeyToggle.checked ? 'flex' : 'none';
          }
          
          let anyHotkeyEnabled = hotkeyOn.some(enabled => enabled);
          keyboardLayoutSection.style.display = anyHotkeyEnabled ? 'block' : 'none';
          
          if (anyHotkeyEnabled) {
            sendKeyboardLayoutToDevice();
          }
        });
        
        updateUI(container);
      });

      document.getElementById('faderToggle').addEventListener('change', function() {
        const isVolumeMode = !this.checked;
        const isSessionActive = checkSessionStatus();
        updateAllFaders(isVolumeMode, isSessionActive);
      });

      document.querySelectorAll('.hotkey-capture-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.target.id;
          const matches = id.match(/hotkey-capture-(down|up)-(\d+)/);
          if (matches) {
            const direction = matches[1];
            const faderIndex = parseInt(matches[2]);
            toggleHotkeyCapture(faderIndex, direction);
          }
        });
      });

      document.addEventListener('keydown', (event) => {
        for (let faderIndex in captureStates) {
          const fader = captureStates[faderIndex];
          if (fader.down.capturing) {
            handleKeyCapture(event, parseInt(faderIndex), 'down');
            return;
          }
          if (fader.up.capturing) {
            handleKeyCapture(event, parseInt(faderIndex), 'up');
            return;
          }
        }
      });
    }

    function populateSelects() {
      const channelSelects = document.querySelectorAll('.channel-select');
      const ccSelects = document.querySelectorAll('.cc-select');
      
      for (let i = 0; i <= 15; i++) {
        const opt = new Option(`CH ${i+1}`, i);
        channelSelects.forEach(sel => sel.appendChild(opt.cloneNode(true)));
      }
      
      for (let i = 0; i <= 127; i++) {
        const opt = new Option(`CC ${i}`, i);
        ccSelects.forEach(sel => sel.appendChild(opt.cloneNode(true)));
      }
    }

    detectAndSetDefaultKeyboardLayout();
    createSliders();

let port = null;
let reader = null;
let inputDone = null;
let outputDone = null;
let outputStream = null;
let writer;

connectBtn.addEventListener('click', async () => {
  if (port) {
    disconnect();
   
    const isVolumeMode = !document.getElementById('faderToggle').checked;
    updateAllFaders(isVolumeMode, false);
   
    return;
  }
  try {
    connectBtn.textContent = 'Connecting...';
    connectBtn.disabled = true;
 
    console.log('üîå Starting serial connection...');
    port = await navigator.serial.requestPort({
      filters: [{ usbVendorId: 0x1b4f }]
    });
    await port.open({ baudRate: 9600 });
    const encoder = new TextEncoderStream();
    outputDone = encoder.readable.pipeTo(port.writable);
    outputStream = encoder.writable;
    writer = outputStream.getWriter();
    const decoder = new TextDecoderStream();
    inputDone = port.readable.pipeTo(decoder.writable);
    reader = decoder.readable.getReader();
    console.log('‚úÖ Serial connection established');
 
    connectBtn.textContent = 'Disconnect';
    connectBtn.disabled = false;
    saveBtn.style.display = 'block';
    saveDesc.style.display = 'block';
 
    console.log('‚úÖ Serial connection completed');
   
    const isVolumeMode = !document.getElementById('faderToggle').checked;
    updateAllFaders(isVolumeMode, true);
 
    readSerial();
    sendCommand("stato_iniziale");
  } catch (err) {
    console.error('‚ùå Connection error:', err);
    
    if (err.name === 'InvalidStateError' || err.message.includes('Failed to open serial port')) {
      alert('‚ö†Ô∏è Serial port already in use!\n\nThe port is already occupied by another application or browser tab.\n\nClose all other connections to the serial port and try again.');
    } else if (err.name === 'NotFoundError') {
      console.log('Port selection cancelled by user');
    } else {
      alert('‚ùå Connection error\n\n' + err.message);
    }
    
    connectBtn.textContent = 'Connect';
    connectBtn.disabled = false;
   
    const isVolumeMode = !document.getElementById('faderToggle').checked;
    updateAllFaders(isVolumeMode, false);
 
    if (port) {
      try {
        await port.close();
      } catch (closeErr) {
        console.error('Error closing port:', closeErr);
      }
      port = null;
    }
  }
});

async function disconnect() {
  try {
    if (reader) {
      await reader.cancel();
      await inputDone.catch(() => {});
      reader = null;
      inputDone = null;
    }
   
    if (writer) {
      await writer.close();
      writer = null;
    }
   
    if (outputStream) {
      await outputDone;
      outputStream = null;
      outputDone = null;
    }
   
    if (port) {
      await port.close();
      port = null;
    }
   
    connectBtn.textContent = 'Connect';
    saveBtn.style.display = 'none';
    saveDesc.style.display = 'none';
    console.log('üîå Serial disconnected');
  } catch (err) {
    console.error('Error during disconnection:', err);
    reader = null;
    writer = null;
    outputStream = null;
    outputDone = null;
    inputDone = null;
    port = null;
    connectBtn.textContent = 'Connect';
    saveBtn.style.display = 'none';
    saveDesc.style.display = 'none';
  }
}

function handleMidiConfigMessage(midiData) {
  const hexData = midiData.substring(2);
  
  for (let i = 0; i < NUM_FADER && i * 4 < hexData.length; i++) {
    const channelHex = hexData.substring(i * 4, i * 4 + 2);
    const ccHex = hexData.substring(i * 4 + 2, i * 4 + 4);
    
    const channel = parseInt(channelHex, 16);
    const controlChange = parseInt(ccHex, 16);
    
    if (!isNaN(channel) && !isNaN(controlChange)) {
      midiChannels[i] = channel;
      midiControlChanges[i] = controlChange;
      
      const halfFaders = NUM_FADER / 2;
      let containerIndex, targetGroup;
      
      if (i < halfFaders) {
        containerIndex = i;
        targetGroup = document.querySelector('.container-1');
      } else {
        containerIndex = i - halfFaders;
        targetGroup = document.querySelector('.container-2');
      }
      
      const containers = targetGroup.querySelectorAll('.slider-container');
      const container = containers[containerIndex];
      
      if (container) {
        const channelSelect = container.querySelector('.channel-select');
        const ccSelect = container.querySelector('.cc-select');
        
        if (channelSelect && ccSelect) {
          channelSelect.value = channel;
          ccSelect.value = controlChange;
        }
      }
    }
  }
  
  console.log('üì© MIDI configuration received:', midiChannels, midiControlChanges);
}

function handleHotkeyStateMessage(message) {
  const trimmed = message.trim();
  
  if (trimmed.startsWith('k,')) {
    const languageCode = parseInt(trimmed.substring(2));
    if (!isNaN(languageCode) && languageCode >= 0 && languageCode <= 8) {
      currentKeyboardLayoutCode = languageCode;
      keyboardLayoutSelect.value = languageCode.toString();
      console.log(`üì© Keyboard language received: ${languageCode}`);
    }
    return;
  }
  
  if (!trimmed.startsWith('sd,') && !trimmed.startsWith('su,')) {
    return;
  }
  
  const parts = trimmed.split(',');
  if (parts.length !== 2) {
    console.warn('Invalid hotkey format:', trimmed);
    return;
  }
  
  const direction = parts[0];
  const data = parts[1];
  
  if (data.length < 5) {
    console.warn('Hotkey data too short:', data);
    return;
  }
  
  const faderIndex = parseInt(data.substring(0, 1));
  const hexData = data.substring(1);
  
  if (isNaN(faderIndex) || faderIndex < 0 || faderIndex >= NUM_FADER) {
    console.warn('Invalid fader index:', faderIndex);
    return;
  }
  
  if (hexData.length !== 4) {
    console.warn('Invalid hotkey hex data:', hexData);
    return;
  }
  
  const modifiersHex = hexData.substring(0, 2);
  const mainKeyHex = hexData.substring(2, 4);
  
  const modifiers = parseInt(modifiersHex, 16);
  const mainKey = parseInt(mainKeyHex, 16);
  
  if (isNaN(modifiers) || isNaN(mainKey)) {
    console.warn('Hex conversion failed for:', hexData);
    return;
  }
  
  const keys = convertHexToKeys(modifiers, mainKey);
  
  if (keys.length === 0) {
    console.warn('No valid keys found for:', hexData);
    return;
  }
  
  const displayFaderIndex = faderIndex + 1;
  const captureDirection = direction === 'sd' ? 'down' : 'up';
  
  if (!captureStates[displayFaderIndex]) {
    captureStates[displayFaderIndex] = {
      down: {capturing: false, keys: []},
      up: {capturing: false, keys: []}
    };
  }
  
  captureStates[displayFaderIndex][captureDirection].keys = keys;
  
  updateHotkeyDisplay(displayFaderIndex, captureDirection);
  
  console.log(`üì© Hotkey ${captureDirection} received for Fader ${displayFaderIndex}: ${keys.join(' + ')}`);
}

function convertHexToKeys(modifiers, mainKey) {
  const keys = [];
  
  if (modifiers & 0x01) keys.push('Ctrl');
  if (modifiers & 0x02) keys.push('Alt');
  if (modifiers & 0x04) keys.push('Shift');
  if (modifiers & 0x08) keys.push('Win');
  
  if (mainKey !== 0) {
    const mainKeyName = findKeyByHex(mainKey);
    if (mainKeyName) {
      keys.push(mainKeyName);
    } else {
      if (mainKey >= 32 && mainKey <= 126) {
        keys.push(String.fromCharCode(mainKey));
      } else {
        console.warn(`Unmapped main key: 0x${mainKey.toString(16)}`);
      }
    }
  }
  
  return keys;
}

function findKeyByHex(hexValue) {
  for (const [keyName, keyHex] of Object.entries(keyToHexMap)) {
    if (keyHex === hexValue) {
      return keyName;
    }
  }
  
  const currentLayoutCode = parseInt(keyboardLayoutSelect.value);
  const layoutName = Object.keys(supportedLayouts).find(
    layout => supportedLayouts[layout] === currentLayoutCode
  );
  
  if (layoutName && keyboardSpecialChars[layoutName]) {
    for (const [char, charHex] of Object.entries(keyboardSpecialChars[layoutName])) {
      if (charHex === hexValue) {
        return char;
      }
    }
  }
  
  return null;
}

    async function readSerial() {
      while (true) {
        const { value, done } = await reader.read();
        if (done || value === undefined) break;
        
        buffer += value;
        
        const messages = buffer.split('\n');
        buffer = messages.pop() || '';
        
        messages.forEach(message => {
          const trimmed = message.trim();
          if (trimmed === '') return;
          
          if (trimmed.startsWith('f,')) {
            const numFaderValue = parseInt(trimmed.substring(2));
            if (!isNaN(numFaderValue) && (numFaderValue === 6 || numFaderValue === 8 || numFaderValue === 10)) {
              NUM_FADER = numFaderValue;
              
              let deviceName = '';
              if (NUM_FADER === 6) {
                deviceName = 'TriFader';
              } else if (NUM_FADER === 8) {
                deviceName = 'QuadraFader';
              } else if (NUM_FADER === 10) {
                deviceName = 'PentaFader';
              }
              
              panelTitle.innerHTML = `<span class="fader-name">${deviceName}</span> Configurator`;
              document.title = `${deviceName} Configurator`;
              createSliders();
              updateFaderToggleUI();
            }
          } else if (trimmed.startsWith('i,')){
            const valoreInterruttore = parseInt(trimmed.substring(2));

            if (valoreInterruttore === 0) {
            toggle.checked = false;
            currentSession = 'A';
            group1.style.display = 'flex';
            group2.style.display = 'none';
            updateFaderToggleUI();
          } else if (valoreInterruttore === 1) {
            toggle.checked = true;
            currentSession = 'B';
            group1.style.display = 'none';
            group2.style.display = 'flex';
            updateFaderToggleUI();
          } 

          } else if (trimmed === 'on_a') {
            faderStateA = false;
            if (currentSession === 'A') {
              faderToggle.checked = false;
            }
          } else if (trimmed === 'off_a') {
            faderStateA = true;
            if (currentSession === 'A') {
              faderToggle.checked = true;
            }
          } else if (trimmed === 'on_b') {
            faderStateB = false;
            if (currentSession === 'B') {
              faderToggle.checked = false;
            }
          } else if (trimmed === 'off_b') {
            faderStateB = true;
            if (currentSession === 'B') {
              faderToggle.checked = true;
            }
          } else if (trimmed.startsWith('la,')) {
            const parts = trimmed.substring(3).split(',');
            if (parts.length >= 1) {
              const ledValue = parseInt(parts[0]);
              ledStateA = (ledValue === 1);
              if (parts.length >= 2) {
                ledValueA = parseInt(parts[1]);
              }
              if (currentSession === 'A') {
                updateFaderToggleUI();
              }
            }
          } else if (trimmed.startsWith('lb,')) {
            const parts = trimmed.substring(3).split(',');
            if (parts.length >= 1) {
              const ledValue = parseInt(parts[0]);
              ledStateB = (ledValue === 1);
              if (parts.length >= 2) {
                ledValueB = parseInt(parts[1]);
              }
              if (currentSession === 'B') {
                updateFaderToggleUI();
              }
            }
          } else if (trimmed.startsWith('m,') && trimmed.length > 2) {
            handleMidiConfigMessage(trimmed);
          }
           else if (trimmed.startsWith('v,')) {
            const volumeIndexValue = parseInt(trimmed.substring(2).trim());
            handleVolumeMessage(volumeIndexValue);
          } else if (trimmed.startsWith('h,')) {
            const hotkeyIndexValue = parseInt(trimmed.substring(2).trim());
            handleHotkeyMessage(hotkeyIndexValue);
          } else if (trimmed.includes('|')) {
            handleSliderValues(trimmed);
          } else if (trimmed.startsWith('sd,') || trimmed.startsWith('su,') || trimmed.startsWith('k,')) {
            handleHotkeyStateMessage(trimmed);
          }
        });
      }
    }

    async function sendCommand(cmd) {
      if (writer) {
        await writer.write(cmd + "\n");
        console.log("üì§ Sent:", cmd);
      }
    }

    document.querySelector('.hotkey-spoiler-header').addEventListener('click', () => {
      const spoiler = document.querySelector('.hotkey-spoiler');
      spoiler.classList.toggle('open');
    });

function updateFaderVisualState(faderElement, isVolumeMode, isFaderEnabled, isSessionActive) {
  const slider = faderElement.querySelector('.slider');
  if (!slider) return;

  slider.classList.remove('midi-mode', 'volume-mode');

  const shouldBeBlue = isVolumeMode && isFaderEnabled && isSessionActive;

  if (shouldBeBlue) {
    slider.style.setProperty('--thumb-border-color', '#0099ff');
  } else {
    slider.style.setProperty('--thumb-border-color', '#666');
  }
}

function updateAllFaders(isVolumeMode, isSessionActive) {
  const faderContainers = document.querySelectorAll('.slider-container');
  
  faderContainers.forEach((container, index) => {
    const modeSelect = container.querySelector('.mode-select');
    const isMidiMode = modeSelect.value === 'midi';
    
    updateFaderVisualState(container, isVolumeMode && !isMidiMode, true, isSessionActive);
  });
}

function checkSessionStatus() {
  const connectButton = document.getElementById('connectButton');
  return connectButton.textContent.includes('Disconnect');
}
  </script>
</body>
</html>